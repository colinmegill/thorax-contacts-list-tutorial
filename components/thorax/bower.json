{
  "name": "thorax",
  "version": "2.0.0rc9",
  "dependencies": {
    "jquery": "1.9.0",
    "underscore": "1.4.4",
    "zepto": "1.0.0",
    "handlebars": "1.0.0",
    "backbone": "1.0.0"
  },
  "gitHead": "2098cc30fe6f1125eb8cc56d15f533bed636ebd9",
  "readme": "# Thorax\n\nAn opinionated, battle tested [Backbone](http://backbonejs.org/) + [Handlebars](http://handlebarsjs.com/) framework to build large scale web applications.\n\n# Quick Start\n\n- Clone the [Seed Project](http://github.com/walmartlabs/thorax-seed) and start building your own application.\n- Read about how Thorax works in the new [Backbone Fundamentals Book](http://addyosmani.github.com/backbone-fundamentals/#thorax).\n- Install the [Thorax Inspector](https://chrome.google.com/webstore/detail/thorax-inspector/poioalbefcopgeaeaadelomciijaondk) Chrome extension.\n- Building something smaller? Just link the [core library](http://github.com/walmartlabs/thorax) as a [single file from cdnjs](http://cdnjs.cloudflare.com/ajax/libs/thorax/2.0.0rc6/thorax.js) compiled with all of its dependencies and use it anywhere or play with our [Hello World fiddle](http://jsfiddle.net/KRuPZ/) or [Todos fiddle](http://jsfiddle.net/mZzhy/).\n\n# Features\n\n## Hello World\n\nThorax is used to build some of the biggest Backbone applications in the world but it's easy to get started.\n\n    var view = new Thorax.View({\n      greeting: \"Hello\",\n      template: Handlebars.compile(\"{{greeting}} world!\")\n    });\n    view.appendTo('body');\n\n## Easy Data Binding\n\nBy default every property of your view is automatically available in the template. If a model is bound its attributes will also be made available.\n\n    var view = new Thorax.View({\n      greeting: 'Hello',\n      model: new Thorax.Model({\n        location: 'world!'\n      }),\n      template: ...\n    });\n\nThen in your template:\n\n    {{greeting}} {{location}}\n\n## Context Control\n\nDon't like every property in your view being available in your template, or need to modify some model attributes? Just specify a `context` method to control what your template sees:\n\n    var view = new Thorax.View({\n      model: new Thorax.Model({\n        greeting: 'hello'\n      }),\n      context: function() {\n        return {\n          greeting: this.model.get('greeting').toUpperCase()\n        };\n      },\n      template: ...\n    });\n\nThen in your template:\n\n    {{greeting}}\n\n## Collection Rendering\n\nEasily render collections with the `collection` helper. Thorax will make sure that your view stays current as models in your collection are added, removed or updated.\n\n    var view = new Thorax.View({\n      collection: new Thorax.Collection([{\n        title: 'Finish screencast',\n        done: true\n      }]),\n      template: ...\n    });\n\nThen in your template:\n\n    {{#collection tag=\"ul\"}}\n      <li>\n        <input type=\"checkbox\" {{#done}}checked{{/done}}\n        {{title}}\n      </li>\n    {{else}}\n      <li>No todos yet.</li>\n    {{/collection}}\n\n## jQuery and Zepto Integration\n\nThorax extends the jQuery or Zepto `$` object to allow you to get a reference to the nearest bound `model`, `collection`, or `view`.\n\n    var view = new Thorax.View({\n      events: {\n        'change input[type=checkbox]': function(event) {\n          var model = $(event.target).model();\n          model.set({done: event.target.checked});\n        }\n      }\n    });\n\n## Event Enhancements\n\nThorax extends the events hash to let you listen to view events in addition to DOM events, and let's you pass a hash of `model` or `collection` events to `listenTo` when a model or collection is bound to your view.\n\n    var view = new Thorax.View({\n      events: {\n        rendered: function() {}\n        model: {\n          change: function() {}\n        }\n      },\n      model: new Thorax.Model()\n    });\n\nThorax also adds inheritable events to view classes, just call `on` on any class to listen for a DOM, view, model or collection event on any view.\n\n    Thorax.View.on('eventName', handler);\n\n## Form Handling\n\nEasily capture entered form data with the `serialize` method which also provides event hooks for form validation. Models bound to the view will also automatically `populate` your forms.\n\n    var view = new Thorax.View({\n      events: {\n        'submit form': function(event) {\n          event.preventDefault();\n          var attrs = this.serialize();\n          this.collection.add(attrs);\n        }\n      },\n      collection: new Thorax.Collection()\n    });\n\n## Embeddable Views\n\nEasily embed one view within another with the `view` helper.\n\n    var view = new Thorax.View({\n      child: new Thorax.View(...),\n      template: ...\n    });\n\nThen in your template:\n\n    {{view child}}\n\n## Layouts and Lifecycle\n\n`Thorax.LayoutView` provides a container to place your views, and triggers lifecycle events on views placed within them. Layouts can be embedded in other views as well.\n\n    var layout = new Thorax.LayoutView();\n    layout.appendTo('body');\n    var view = new Thorax.View({\n      events: {\n        ready: function() {},\n        destroyed: function() {}\n      }\n    })\n    layout.setView(view);\n\n# Getting Started\n\n## Tutorials\n\n### [From zero to todos](https://github.com/walmartlabs/thorax-seed/blob/master/README.md)\n\nDid you enjoy the [screencast](http://vimeo.com/60230630)? Learn how to build your own simple todos app from scratch, with [step by step explanations](https://github.com/walmartlabs/thorax-seed/blob/master/README.md) of how the app was built.\n\n### [Thorax in Backbone Fundamentals](http://addyosmani.github.com/backbone-fundamentals/#thorax)\n\nRead an overview of the features of Thorax, as well as some of the theory behind some of the implementation details.\n\n### [Route Based Module Loading](http://addyosmani.github.com/backbone-fundamentals/#route-based-module-loading)\n\n[Backbone Fundamentals](http://addyosmani.github.com/backbone-fundamentals/) also covers [Lumbar's](http://walmartlabs.github.com/lumbar) approach to modular application development and routing, which is used in all of the seed projects except the standalone and Rails seeds.\n\n### TodoMVC\nSee the [TodoMVC Thorax implementation](http://addyosmani.github.com/todomvc/labs/architecture-examples/thorax/) and its [source code](https://github.com/addyosmani/todomvc/tree/gh-pages/labs/architecture-examples/thorax). There is also a [Lumbar flavored version](https://github.com/addyosmani/todomvc/tree/gh-pages/labs/dependency-examples/thorax_lumbar) of the implementation.\n\n## Resources\n\n### Seeds\n\nCloning a seed is the easiest way to get started building your own project.\n\n- [Root Seed](https://github.com/walmartlabs/thorax-seed)\n- [with Mocha test harness](https://github.com/eastridge/thorax-seed-mocha)\n- [with simple Todos](https://github.com/eastridge/thorax-seed-todos)\n- [Rails Seed (zip)](https://github.com/walmartlabs/thorax-boilerplate/blob/master/rails.zip?raw=true)\n- [Standalone / HTML only Seed (zip)](https://github.com/walmartlabs/thorax-boilerplate/blob/master/standalone.zip?raw=true)\n\n### Bower component\n\nThorax is available as a [Bower](http://bower.io/) component. Just run `bower install thorax` in your project.\n\n### cdnjs\n\nThorax is available on [cdnjs](http://cdnjs.com/), each build includes jQuery 1.9.0 (or Zepto 1.0.0rc1 on mobile), Backbone 0.9.9, Underscore 1.4.2 and Handlebars 1.0.0rc6.\n\n- [Thorax](http://cdnjs.cloudflare.com/ajax/libs/thorax/2.0.0rc6/thorax.js)\n- [Thorax (compressed)](http://cdnjs.cloudflare.com/ajax/libs/thorax/2.0.0rc6/thorax.min.js)\n- [Thorax Mobile](http://cdnjs.cloudflare.com/ajax/libs/thorax/2.0.0rc6/thorax-mobile.js)\n- [Thorax Mobile (compressed)](http://cdnjs.cloudflare.com/ajax/libs/thorax/2.0.0rc6/thorax-mobile.min.js)\n\n### Chrome Inspector Extension\n\nChrome users can install the [Thorax Inspector](https://chrome.google.com/webstore/detail/thorax-inspector/poioalbefcopgeaeaadelomciijaondk) Chrome extension which will allow you to inspect any element and see the associated Thorax views, models and collections that may be bound. The [Thorax Seed](https://github.com/walmartlabs/thorax-seed) also integrates the [thorax-inspector](https://npmjs.org/package/thorax-inspector) npm package which allows you to open files in your project that relate to a given element, directly from Chrome.\n\n### Playground\n\nWhen combined with CoffeeScript small Thorax apps can be written in a single file. This is ideal for creating small test apps within [JSFiddle](http://jsfiddle.net/). Thorax can be selected as a framework (near the bottom of the list) in any fiddle, or you can try out any of the fiddles below:\n\n- [Hello World](http://jsfiddle.net/KRuPZ/)\n- [Todos](http://jsfiddle.net/mZzhy/)\n- [$](http://jsfiddle.net/aveVu/)\n- [HelperView](http://jsfiddle.net/NfkA5/)\n- [LayoutView & Lifecycle](http://jsfiddle.net/cR6D8/)\n- [Embedding](http://jsfiddle.net/6sCgX/)\n\n# API Reference\n\n## Registry\n\nThorax creates a special hash for each type of class to store all subclasses in your application. The use of `Thorax.Views` and `Handlebars.templates` (usually defined by Handlebars) is required to allow the `view`, `template` and other helper methods to operate, but the use of `Thorax.Models` and `Thorax.Collections` are optional and provided for consitency.\n\n<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" width=\"100%\">\n  <thead>\n    <tr>\n      <th>Class</th>\n      <th>Registry</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr><td>Thorax.View</td><td>Thorax.Views</td></tr>\n    <tr><td>Thorax.Model</td><td>Thorax.Models</td></tr>\n    <tr><td>Thorax.Collection</td><td>Thorax.Collections</td></tr>\n    <tr><td>templates</td><td>Handlebars.templates</td></tr>\n  </tbody>\n</table>\n\n### name *klass.prototype.name*\n\nIf a `name` property is passed to any Thorax classes' `extend` method the resulting class will be automatically set in the corresponding registry.\n\n    //set class\n    Thorax.View.extend({\n      name: \"my-view\"\n    });\n\n    //get class\n    Thorax.Views[\"my-view\"]\n\n### templates *Handlebars.templates*\n\nA hash of templates, used by various Thorax helpers. If using the Lumbar or Rails boilerplate projects or the [Thorax Seed](http://github.com/walmartlabs/thorax-seed) this hash will be automatically generated from the files in your `templates` directories. To manually add a template to the hash:\n\n    Handlebars.templates['my-template-name'] = Handlebars.compile('template string');\n\nIf a `View` has the same `name` as a template in the `templates` hash, its `template' property will be automatically assigned.\n\n## Thorax.View\n\n`Thorax.View` provides additive functionality over `Backbone.View` but breaks compatibility in one imporant way in that it does not use an `options` object. All properties passed to the constructor become available on the instance:\n\n    var view = new Thorax.View({\n      key: \"value\"\n    });\n    view.key === \"value\"\n\nBy default all instance properties are available in the template context. So when setting a key on the view it will by default be available in the template.\n\n### template *view.template*\n\nAssign a template to a view. This may be a string or a function which recieves a single `context` argument and returns a string. If the view has a `name` and a template of the same `name` is available the `template` will be auto-assigned.\n\n    new Thorax.View({\n      template: Handlebars.compile(\"{{key}}\")\n    });\n\n### render *view.render([content])*\n\nRenders the view's `template` updating the view's `el` with the result, triggering the `rendered` event.\n\n    view.render();\n\n`render` can also accept a content argument that may be an element, string or a template function:\n\n    view.render('custom html');\n\n### context *view.context()*\n\nUsed by `render` to determine what attributes are available in the view's `template`. The default context function returns `this` + `this.model.attributes` if a `model` is present on the view. The `context` method may be overriden to provide a custom context:\n\n    new Thorax.View({\n      template: Handlebars.compile('{{key}}'),\n      context: function() {\n        return _.defaults(this.model.attributes, {\n          key: 'value'\n        });\n      }\n    });\n\n### appendTo *view.appendTo(element)*\n\nAppends the view to a given `element` which may be a CSS selector or DOM element. `ensureRendered` will be called and a `ready` event will be triggered. This is the preferred way to append your outer most view onto a page.\n\n### renderTemplate *view.renderTemplate(name [,context])*\n\nRenders a given template with the view's `context` or the given context argument.\n\n### ensureRendered *view.ensureRendered()*\n\nEnsure that the view has been rendered at least once.\n\n### conditionalRender *view.conditionalRender([flag])*\n\nRenders the view if and only if `shouldRender(flag)` is true. Useful for ensuring that updates occur while still deferring final rendering until the view has been inserted into the DOM.\n\nWhen `flag` is `undefined` this is effectively the opposite behavior of `ensureRendered`.\n\n### shouldRender *view.shouldRender([flag])*\n\nReturns `true` if the view should be rendered based on `flag` and the current rendered state.\n\n`flag` may be:\n- `true` : Always render\n- `false` : Never render\n- `undefined` : Render only if the view has been rendered previously\n\n### html *view.html([content])*\n\nGet or set the `innerHTML` of the view, without triggering the `rendered` event.\n\n### children *view.children*\n\nA hash of child view's indexed by `cid`. Child views may become attached to the parent with the `view` helper or may be automatically attached `HelperView` instances created by helpers created with `regsterViewHelper` (such as the `collection` and `empty` helpers).\n\n### parent *view.parent*\n\nIf a view was embedded inside another with the `view` helper, or a generated `HelperView` (for instance the `collection` or `empty` helpers) it will have a `parent` view attribute. In the case of `HelperView`s, the `parent` will be the view that declared the helper in its template.\n\n### destroy *view.destroy([options])*\n\nCalls `remove` (and therefore `$el.remove` and `stopListening`) on your view, unbinds any model or collection bound with `setCollection` or `setModel`, calls `destroy` on all children, then triggers a `destroyed` event which can be used to implement specific cleanup behaviors in your views. Pass `children: false` to this method to prevent the view's children from being destroyed.\n\n`destroy` will also be called on a view if it was previously passed to the `setView` method on a `LayoutView`, and then another view is passed to `setView`.\n\n### setModel *view.setModel(model [,options])*\n\nSetting `model` in the construtor will automatically call `setModel`, so the following are equivelent:\n\n    var view = new Thorax.View({\n      model: myModel\n    });\n    // identical functionality as above\n    view.setModel(myModel);\n\nSets the `model` attribute of a view then attempts to fetch the model if it has not yet been populated. Once set the default `context` implementation will merge the model's `attributes` into the context, so any model attributes will automatically become available in a template. In addition any events declared via `view.on({model: events})` will be bound to the model with `listenTo`.\n\nAccepts any of the following options:\n\n- **fetch** - Boolean, whether to fetch the model when it is set, defaults to true.\n- **success** - Callback on fetch success, defaults to noop\n- **render** - Render on the view on model:change? Defaults to undefined\n  - `true` : Always render on change\n  - `false` : Never render on change\n  - `undefined` : Rerender if we have already been rendered\n- **populate** - Call `populate` with the model's attributes when it is set? Defaults to true. Pass `populate: {children: false}` to prevent child views from having their inputs populated.\n- **errors** - When the model triggers an `error` event, trigger the event on the view? Defaults to true\n\n### setCollection *view.setCollection(collection [,options])*\n\nSetting `collection` in the construtor will automatically call `setCollection`, so the following are equivelent:\n\n    var view = new Thorax.View({\n      collection: myCollection\n    });\n    // identical functionality as above\n    view.setCollection(myCollection);\n\nSets the `collection` attribute of a view then attempts to fetch the collection if it has not yet been populated. In addition any events declared via `view.on({collection: events})` will be bound to the collection with `listenTo`.\n\nAccepts any of the following options:\n\n- **render** - Whether to render the collection if it is populated, or render it after it has been loadedundefined\n  - `true` : Always render on change\n  - `false` : Never render on change\n  - `undefined` : Rerender if we have already been rendered\n- **fetch** - Whether or not to try to call `fetch` on the collection if `shouldFetch` returns true\n- **success** - Callback on fetch success, defaults to noop\n- **errors** - Whether or not to trigger an `error` event on the view when an `error` event is triggered on the collection\n\nNote that while any view may bind a collection only a `CollectionView` will actually render a collection. A regular `Thorax.View` may declare a `collection` helper which in turn will generate and embed a `CollectionView`.\n\n### serialize *view.serialize([event], callback [,options])*\n\nSerializes a form. `callback` will receive the attributes from the form, followed by a `release` method which must be called before the form can be submitted again. `callback` will only be called if `validateInput` returns nothing or an empty array. `options` may contain:\n\n- `set` - defaults to true, whether or not to set the attributes if valid on a model if one was set with `setModel`\n- `validate - defaults to true, whether or not to call `validateInput` during serialization\n- `children` - defaults to true, whether or not to serialize inputs in child views\n- `silent` - defaults to true, whether or not to pass `silent: true` to `model.set`\n\nEach form input in your application should contain a corresponding label. Since you may want to re-use the same form multiple times in the same view a `@cid` attribute with a unique value is provided to each render call of each template:\n\n    <label for=\"{{@cid}}-last-name\"/>\n    <input name=\"last-name\" id=\"{{@cid}}-last-name\" value=\"Beastridge\"/>\n    <label for=\"{{@cid}}-address[street]\"/>\n    <input name=\"address[street]\" value=\"123 Chestnut\" id=\"{{@cid}}-address[street]\"/>\n\n    new Thorax.View({\n      events: {\n        \"submit form\": function(event) {\n          this.serialize(event, function(attributes, release) {\n            attributes[\"last-name\"] === \"Beastridge\";\n            attributes.address.street === \"123 Chestnut\";\n            //form is locked to prevent duplicate submission\n            //until release is called\n            release();\n          });\n        }\n      }\n    });\n\n`serialize` Triggers the following events:\n\n- `serialize` - called before validation with serialized attributes\n- `validate` - with an attributes hash and errors array after `validateInput` is called\n- `error` - with an errors array, if validateInput returned an array with any errors\n- `root` - the root element to serialize within, defaults to `this.$el`\n\nIf your view uses inputs with non standard names (or no names, multiple inputs with the same name, etc), use the `serialize` event:\n\n    this.on('serialize', _.bind(function(attributes) {\n      attributes.custom = this.$('.my-input').val();\n    }, this));\n\n### populate *view.populate([attributes] [,options])*\n\nPopulate the form fields in the view with the given attributes. The keys of the attributes should correspond to the names of the inputs. `populate` is automatically called with the response from `view.context()` when `setModel` is called. By default this is just `model.attributes`.\n\n    view.populate({\n      \"last-name\": \"Beastridge\"\n      address: {\n        street: \"123 Chestnut\"\n      }\n    });\n\n`populate` triggers a `populate` event. If your view uses inputs with non standard names (or no names, multiple inputs with the same name, etc), use this event:\n\n    this.on('populate', _.bind(function(attributes) {\n      this.$('.my-input').val(attributes.custom);\n    }, this));\n\nTo prevent child views from having their inputs populated use:\n\n    view.populate(object, {\n      children: false\n    });\n\n### validateInput *view.validateInput(attributes)*\n\nValidate the attributes created by `serialize`, must return an array or nothing (if valid). It's recommended that the array contain hashes with `name` and `message` attributes, but arbitrary data or objects may be passed. If the array has a zero length the attributes are considered to be valid. Returning an array with any errors will trigger the `error` event.\n\n    validateInput: function(attributes) {\n      var errors = [];\n      if (attributes.password && !attributes.password.match(/.{6,11}/)) {\n        errors.push({name: 'password', message: 'Invalid Password'});\n      }\n      return errors;\n    }\n\n\n## Thorax.HelperView\n\n### registerViewHelper *Handlebars.registerViewHelper(name [,viewClass] ,callback)*\n\nNote that this differs from `Handlebars.registerHelper`. Registers a helper that will create and append a new `HelperView` instance, with its `template` attribute set to the value of the captured block. `callback` will recieve any arguments passed to the helper followed by a `HelperView` instance. Named arguments to the helper will be present on `options` attribute of the `HelperView` instance.\n\nA `HelperView` instance differs from a regular view instance in that it has a `parent` attribute which is always set to the declaring view, and a `context` which always returns the value of the `parent`'s context method. The `collection`, `empty` and other built in block view helpers are created with `registerViewHelper`.\n\nA helper that re-rendered a `HelperView` every time an event was triggered on the declaring view could be implemented as:\n\n    Handlebars.registerViewHelper('on', function(eventName, helperView) {\n      helperView.listenTo(helperView.parent, eventName, function() {\n        helperView.render();\n      });\n    });\n\nAn example use of this would be to have a counter that would increment each time a button was clicked. In Handlebars:\n\n    {{#on \"incremented\"}}{{i}}{/on}}\n    {{#button trigger=\"incremented\"}}Add{{/button}}\n\nAnd the corresponding view class:\n\n    new Thorax.View({\n      events: {\n        incremented: function() {\n          ++this.i;\n        }\n      },\n      initialize: function() {\n        this.i = 0;\n      },\n      template: ...\n    });\n\nIn addition, if a view class is specified as the second argument to `registerViewHelper`, the helper will always initialize a view of that class instead of a `HelperView`:\n\n    Handlebars.registerViewHelper('collection',\n      Thorax.CollectionHelperView, function(collection, view) {\n\n    });\n\n## Thorax.LayoutView\n\nA view to contain a single other view which will change over time, (multi-pane single page applications for instance), triggering a series of events . By default this class has no template. If one is specified use the `layout` helper to determine where `setView` will place a view. A `Thorax.LayoutView` is a subclass of `Thorax.View` and may be treated as a view in every regard (i.e. embed multiple `LayoutView` instances in a parent view with the `view` helper).\n\n### setView *view.setView(view [,options])*\n\nSet the current view on the `LayoutView`, triggering `activated`, `ready` and `deactivated` events on the current and previous view during the lifecycle. `ensureRendered` is called on views passed to `setView`. By default `destroy` is called on the previous view when the new view is set. Pass `destroy: false` when setting a view to prevent it from being destroyed at a later time.\n\n### getView *view.getView()*\n\nGet the current view that was previously set with `setView`.\n\n## Thorax.Model\n\nEnhances `Backbone.Model` with the concept of whether or not the model is populated and whether or not it should be automatically fetched. Note that when passing a model to `view.setModel` it must be an instance of `Thorax.Model` and not `Backbone.Model`.\n\n### isEmpty *model.isEmpty()*\n\nUsed by the `empty` helper. In a collection the implementations of `isEmpty` and `isPopulated` differ, but in a model `isEmpty` is an alias for `!isPopulated`.\n\n### isPopulated *model.isPopulated()*\n\nUsed by `setModel` to determine whether or not to fetch the model. The default implementation checks to see if any keys that are not `id` and are not default values have been set.\n\n## Thorax.Collection\n\nEnhances `Backbone.Collection` with the concept of whether or not the collection is populated and whether or not it should be automatically fetched. Note that when passing a collection to `view.setCollection` it must be an instance of `Thorax.Collection` and not `Backbone.Collection`.\n\n### isEmpty *collection.isEmpty()*\n\nUsed by the `empty` helper and the `emptyTemplate` and `emptyItem` options of a `CollectionView` to check whether a collection is empty. A collection is only treated as empty if it `isPopulated` and zero length.\n\n### isPopulated *collection.isPopulated()*\n\nUsed by `setCollection` to determine whether or not to fetch the collection.\n\n## Thorax.CollectionView\n\nA class that renders an `itemTemplate` or `itemView` for each item in a `collection` passed to it in its constructor, or via `setCollection`. The view will automatically update when items are added, removed or changed.\n\nThe `collection` helper will automatically create and embed a `CollectionView` instance for you. If programatic access to the view's methods are needed (for instance calling `appendItem` or specifying an `itemFilter`) it's best to create a `CollectionView` directly and embed it with the `view` helper as you would any other view.\n\n### itemTemplate *view.itemTemplate*\n\nA template name or template function to use when rendering each model. If using the `collection` helper the passed block will become the `itemTemplate`. Defaults to `view.name + '-item'`\n\n### itemView *view.itemView*\n\nA view class to be initialized for each item. Can be used in conjunction with `itemTemplate`.\n\n### itemContext *view.itemContext(model, index)*\n\nA function in the declaring view to specify the context for an `itemTemplate`, recieves model and index as arguments. `itemContext` will not be used if an `itemView` is specified as the `itemView`'s own `context` method will instead be used.\n\n### itemFilter *view.itemFilter(model, index)*\n\nA method, which if present will filter what items are rendered in a collection. Recieves `model` and `index` and must return boolean. The filter will be applied when models' fire a change event, or models are added and removed from the collection. To force a collection to re-filter, trigger a `filter` event on the collection.\n\nItems are hidden and shown with `$.hide` and `$.show` rather than being removed or appended. In performance critical views with large collections consider filtering the collection before it is passed to the view or on the server.\n\n### emptyTemplate *view.emptyTemplate*\n\nA template name or template function to display when the collection is empty. If used in a `collection` helper the inverse block will become the `emptyTemplate`. Defaults to `view.name + '-empty'`\n\n### emptyView *view.emptyView*\n\nA view class to create an instance of when the collection is empty. Can be used in conjunction with `emptyTemplate`.\n\n### loadingTemplate *view.loadingTemplate*\n\nA template name or template function to display when the collection is loading.\n\n### loadingView *view.loadingView*\n\nA view class to create an instance of when the collection is loading.  Can be used in conjunction with `loadingTemplate`.\n\n### loadingPlacement *view.loadingPlacement()*\n\nAn index to place the `loadingView` or `loadingTemplate` at. Defaults to `this.collection.length`.\n\n### appendItem *view.appendItem(modelOrView [,index] [,options])*\n\nAppend a model (which will used to generate a new `itemView` or render an `itemTemplate`) or a view at a given index in the `CollectionView`. If passing a view as the first argument `index` may be a model which will be used to look up the index.\n\nBy default this will trigger a `rendered:item` event, `silent: true` may be passed in the options hash to prevent this. To also prevent the appeneded item from being filtered if an `itemFilter` is present pass `filter: false` in the options hash.\n\n### removeItem *view.removeItem(model)*\n\nRemove an item from the view.\n\n### updateItem *view.updateItem(model)*\n\nEquivelent to calling `removeItem` then `appendItem`. Note that this is mainly meant to cover edge cases, by default changing a model will update the needed item (whether using `itemTemplate` or `itemView`).\n\n## Thorax.Util\n\n### tag *Thorax.Util.tag(name, htmlAttributes [,content] [,context])*\n\nGenerate an HTML string. All built in HTML generation uses this method. If `context` is passed any Handlebars references inside of the htmlAttributes values will rendered with the context.\n\n    Thorax.Util.tag(\"div\", {\n      id: \"div-{{number}}\"\n    }, \"content of the div\", {\n      number: 3\n    });\n\n## $\n\n### $.view *$(event.target).view([options])*\n\nGet a reference to the nearest parent view. Pass `helper: false` to options to exclude `HelperView`s from the lookup. Useful when registering DOM event handlers:\n\n    $(event.target).view();\n\n### $.model *$(event.target).model([view])*\n\nGet a reference to the nearest bound model. Can be used with any `$` object but most useful in event handlers.\n\n    $(event.target).model();\n\nA `view` may be optionally passed to limit the lookup to a specific view.\n\n### $.collection *$(event.target).collection([view])*\n\nGet a reference to the nearest bound collection. Can be used with any `$` object but most useful in event handlers.\n\n    $(event.target).collection();\n\nA `view` may be optionally passed to limit the lookup to a specific view.\n\n## Event Enhancements\n\nThorax adds inheritable class events for all Thorax classes and significant enhancements to the Thorax.View event handling.\n\n### Inheritable Events *ViewClass.on(eventName, callback)*\n\nAll Thorax classes have an `on` method to observe events on all instances of the class. Subclasses inherit their parents' event handlers. Accepts any arguments that can be passed to `viewInstance.on` or declared in the `events` hash.\n\n    Thorax.View.on({\n      'click a': function(event) {\n\n      }\n    });\n\n### Model Events\n\nWhen a model is bound to a view with `setModel` (automatically called by passing a `model` option in the constructor) any events on the model can be observed by the view in this way. For instance to observe any model `change` event when it is bound to any view:\n\n    Thorax.View.on({\n      model: {\n        change: function() {\n          // \"this\" will refer to the view\n        }\n      }\n    });\n\n### Collection Events\n\nWhen a collection is bound to a view with `setCollection` (automatically called by passing a `collection` option in the constructor) any events on the collection can be observed by the view in this way. For instance to observe any collection `reset` event when it is bound to any view:\n\n    Thorax.View.on({\n      collection: {\n        reset: function() {\n          // \"this\" will refer to the view\n        }\n      }\n    });\n\n### View Events *view.events.viewEventName*\n\nThe `events` hash has been enhanced to allow view events to be registered along side DOM events:\n\n    Thorax.View.extend({\n      events: {\n        'click a': function(event) {},\n        rendered: function() {}\n      }\n    });\n\n### DOM Events *view.on(eventNameAndSelector, callback [,context])*\n\nThe `on` method will now accept event strings in the same format as the events hash, for instance `click a`. Events separated by a space will still be treated as registering multiple events so long as the event name does not start with a DOM event name (`click`, `change`, `mousedown` etc).\n\nDOM events observed in this way will only operate on the view itself. If the view embeds other views with the `view` helper that would match the event name and selector, they will be ignored. For instance declaring:\n\n    view.on('click a', function(event) {})\n\nWill only listen for clicks on `a` elements within the view. If the view has children that has `a` elements, this handler will not observe clicks on them.\n\nDOM events may be prefixed with the special keyword `nested` which will apply the event to all elements in child views:\n\n    view.on('nested click a', function() {})\n\nThorax will add an attribute to the event named `originalContext` that will be the `Element` object that would have been set as `this` had the handler been registered with jQuery / Zepto:\n\n    $('a').on('click', function() {});\n    view.on('click a', function(event) {\n      // event.originalContext === what \"this\" would be in the\n      // first handler\n    });\n\n### _addEvent *view._addEvent(eventParams)*\n\nThis method is never called directly, but can be specified to override the behavior of the `events` hash or any event arguments passed to `on`. For each event declared in either manner `_addEvent` will be called with a hash containing:\n\n- type \"view\" || \"DOM\"\n- name (DOM events will begin with \".delegateEvents\")\n- originalName\n- selector (DOM events only)\n- handler\n\nAll of the behavior described in this section is implemented via this method, so if overriding make sure to call `Thorax.View.prototype._addEvent` in your child view.\n\n## Data Loading\n\n### Queuing\n\nThorax wraps `fetch` (and therefore `load`) on models and collections with a queuing mechansim to ensure that multiple `sync` calls for the same url will not trigger multiple HTTP requests. To force a `fetch` or `load` call to create a new HTTP request regardless of whether an identical request is in the queue use the `resetQueue` option:\n\n    model.fetch({\n      resetQueue: true\n      success: function() {}\n    });\n\n### bindToRoute *Thorax.Util.bindToRoute(callback [,failback])*\n\nUsed by `model.load` and `collection.load`. Binds the callback to the current route. If the browser navigtates to another route in the time between when the callback is bound and when it is executed, callback will not be called. Else failback will be called if present.\n\n    routerMethod: function() {\n      var callback = Thorax.Util.bindToRoute(function() {\n        //callback called if browser is still on route\n      });\n      setTimeout(callback, 5000);\n    }\n\n### load *modelOrCollection.load(callback [,failback] [,options])*\n\nCalls `fetch` on the model or collection ensuring the callbacks will only be called if the route does not change. `callback` and `failback` will be used as arguments to `bindToRoute`. `options` will be passed to the `fetch` call on the model or collection if present.\n\n    routerMethod: function(id) {\n      var view = new Thorax.View();\n      var model = new Application.Model({id: id});\n      model.load(function() {\n        //callback only called if browser still on this route\n        view.setModel(model);\n        myLayoutView.setView(view);\n      }, function() {\n        //failback only called if browser has left this route\n      });\n    }\n\nTriggers `load:start` and `load:end` events on the model or collection, and additionally on a view if it has bound the object via `setModel` or `setCollection`.\n\nBy default the events will propagate to a root object set with `setRootObject`. Pass `background: true` as an option to prevent the event from being triggered on the rootObject.\n\n\n### setRootObject *Thorax.setRootObject(obj)*\n\nSet the root object that will recieve `load:start` and `load:end` events if the `load:start` was not a `background` event. This is useful to implement a global loading indicator.\n\n### loadHandler *Thorax.loadHandler(startCallback, endCallback)*\n\nGenerates an `load:start` event handler that when triggered will then monitor the associated object for a `load:end` event. If the duration between the start and and the end events exceed `_loadingTimeoutDuration` then the `start` and `end` callbacks will be triggered at the appropriate times to allow the display of a loading UI.\n\n    view.on(\"load:start\", Thorax.loadHandler(\n      function(message, background, object) {\n        view.$el.addClass(\"loading\");\n      },\n      function(background, object) {\n        view.$el.removeClass(\"loading\");\n      }));\n\n### _loadingClassName *view._loadingClassName*\n\nClass name to add and remove from a view's `el` when it is loading. Defaults to `loading`.\n\n### _loadingTimeoutDuration *view._loadingTimeoutDuration*\n\nTimeout duration in seconds before a `load:start` callback will be triggered. Defaults to 0.33 seconds. If for instance the `load:end` event was triggered 0.32 seconds after the `load:start` event the `load:start` callback would not be called.\n\n### _loadingTimeoutEndDuration *view._loadingTimeoutEndDuration*\n\nJust like `_loadingTimeoutDuration` but applies to `load:end`. Defaults to 0.10 seconds.\n\n## Template Helpers\n\n### template *{{template name [options]}}*\n\nEmbed a template inside of another, as a string. An associated view (if any) will not be initialized. By default the template will be called with the current context but extra options may be passed which will be added to the context.\n\n    {{template \"path/to/template\" key=\"value\"}}\n\nIf a block is used, the template will have a variable named `@yield` available that will contain the contents of the block.\n\n    {{#template \"child\"}}\n      content in the block will be available in a variable\n      named \"@yield\" inside the template \"child\"\n    {{/template}}\n\nThis is useful when a child template will be called from multiple different parents.\n\n### super *{{super}}*\n\nEmbed the `template` from the parent view within the child template.\n\n    {{super}}\n\n### view *{{view name [options]}}*\n\nEmbed one view in another. The first argument may be the name of a new view to initialize or a reference to a view that has already been initialized.\n\n    {{view \"path/to/view\" key=\"value\"}}\n    {{view viewInstance}}\n\nIf a block is specified it will be assigned as the `template` to the view instance:\n\n    {{#view viewInstance}}\n      viewInstance will have this block\n      set as its template property\n    {{/view}}\n\n### element *{{element name [options]}}*\n\nEmbed a DOM element in the view. This uses a placeholder technique to work, if the placeholder must be of a certain type in order to be valid (for instance a `tbody` inside of a `table`) specify a `tag` option.\n\n    {{element domElement tag=\"tbody\"}}\n\n### button *{{#button methodName [htmlAttributes...]}}*\n\nCreates a `button` tag that will call the specified methodName on the view when clicked. Arbitrary HTML attributes can also be specified.\n\n    {{#button \"methodName\" class=\"btn\"}}Click Me{{/button}}\n\nThe tag name may also be specified:\n\n    {{#button \"methodName\" tag=\"a\" class=\"btn\"}}A Link{{/button}}\n\nA `trigger` attribute will trigger an event on the declaring view:\n\n    {{#button trigger=\"eventName\"}}Button{{/button}}\n\nA button can have both a `trigger` attribute and a method to call:\n\n    {{#button \"methodName\" trigger=\"eventName\"}}Button{{/button}}\n\nThe method may also be specified as a `method` attribute:\n\n    {{#button method=\"methodName\"}}Button{{/button}}\n\n### url *{{url urlString expand-tokens=bool}}*\n\nPrepends \"#\" if `Backbone.history.pushSate` is disabled or prepends `Backbone.history.root` if it is enabled. If `expand-tokens=true` is passed, then any handlebars tokens will be resolved with the current context. For example if the context had an `id` attribute `{{id}}` would be replaced with the value of `id`:\n\n    {{url \"articles/{{id}}\" expand-tokens=true}}\n\nMultiple arguments can be passed and will be joined with a \"/\":\n\n    {{url \"articles\" id}}\n\n### link *{{#link url [htmlAttributes...]}}*\n\nCreates an `a` tag that will call `Backbone.history.navigate()` with the given url when clicked. Passes the `url` parameter to the `url` helper with the current context. Do not use this method for creating external links. Like the `url` helper, multiple arguments may be passed as well as an `expand-tokens` option.\n\n    {{#link \"articles/{{id}}\" expand-tokens=true class=\"article-link\"}}Link Text{{/link}}\n\nTo call a method from an `a` tag use the `button` helper:\n\n    {{#button \"methodName\" tag=\"a\"}}My Link{{/button}}\n\nLike the `button` helper, a `trigger` attribute may be specified that will trigger an event on the delcaring view in addition to navigating to the specified url:\n\n    {{#link \"articles\" id trigger=\"customEvent\"}}Link Text{{/link}}\n\nThe href attribute is required but may also be specified as an attribute:\n\n    {{#link href=\"articles/{{id}}\" expand-tokens=true}}Link Test{{/link}}\n\n### collection *{{collection [collection] [options...]}}*\n\nCreates and embeds a `CollectionView` instance, updating when items are added, removed or changed in the collection. If a block is passed it will be used as the `item-template`, which will be called with a context of the `model.attributes` for each model in the collection.\n\n    {{#collection tag=\"ul\"}}\n      <li>{{modelAttr}}</li>\n    {{/collection}}\n\nOptions may contain `tag`, `class`, `id` and the following attributes which will map to the generated `CollectionView` instance:\n\n- `item-template` &rarr; `itemTemplate`\n- `item-view` &rarr; `itemView`\n- `empty-template` &rarr; `emptyTemplate`\n- `empty-view` &rarr; `emptyView`\n- `loading-template` &rarr; `loading-template`\n- `loading-view` &rarr; `loadingView`\n\nAny of the options can be specified as variables in addition to strings:\n\n    {{collection item-view=itemViewClass}}\n\nBy default the collection helper will look for `this.collection`, but if your view contains multiple collections a collection argument may be passed:\n\n    {{collection myCollection}}\n\nWhen rendering `this.collection` many properties will be forwarded from the view that is declaring the collection helper to the generated `CollectionView` instance:\n\n- `itemTemplate`\n- `itemView`\n- `itemContext`\n- `itemFilter`\n- `emptyTemplate`\n- `emptyView`\n- `loadingTemplate`\n- `loadingView`\n- `loadingPlacement`\n\nAs a result the following two views are equivelenet:\n\n    // render with collection helper, collection\n    // properties are forwarded\n    var view = new Thorax.View({\n      collection: new Thorax.Collection(),\n      itemView: MyItemClass,\n      itemContext: function(model, i) {\n        return model.attributes;\n      },\n      template: Handlebars.compile('{{collection}}')\n    });\n\n    // directly create collection view, no property\n    // forwarding will occur\n    var view = new Thorax.View({\n      collectionView: new Thorax.CollectionView({\n        collection: new Thorax.Collection(),\n        itemView: MyItemClass\n        itemContext: function(model, i) {\n          return model.attributes;\n        }\n      }),\n      template: Handlebars.compile('{{view collectionView}}')\n    });\n\n### empty *{{#empty [modelOrCollection]}}*\n\nA conditional helper much like `if` that calls `isEmpty` on the specified object. In addition it will bind events to re-render the view should the object's state change from empty to not empty, or visa versa.\n\n    {{#empty collection}}\n      So empty!\n    {{else}}\n      {{#collection}}{{/collection}}\n    {{/empty}}\n\nTo embed a row within a `collection` helper if it the collection is empty, specify an `empty-view` or `empty-template`. Or use the `else` block of the `collection` helper:\n\n    {{#collection tag=\"ul\"}}\n      <li>Some very fine data</li>\n    {{else}}\n      <li>So very empty</li>\n    {{/collection}}\n\n### collection-element *{{collection-element [htmlAttributes...]}}*\n\nBy default `Thorax.CollectionView` instances have no template. Items will be appended to and removed from the view's `el`. Alternatively a template can be specified and `collection-element` used to specify where the individal items in a collection will be rendered.\n\n    <div>\n      {{collection-element tag=\"ul\" class=\"my-list\"}}\n    </div>\n\n### layout-element *{{layout-element [htmlAttributes...]}}*\n\nBy default `Thorax.LayoutView` instances have no template, `setView` will append directly to the view's `el`. Alternatively a template can be specified and a `layout-element` and `setView` will append to that element.\n\n    <ul>\n      {{layout-element tag=\"li\" id=\"my-layout\"}}\n    </ul>\n\n### loading *{{#loading}}*\n\nA block helper to use when the view is loading. For collection specific loading the a `CollectionView` accepts `loadingView` and `loadingTemplate` options to append an item in a collection when it is loading.\n\n    {{#loading}}\n      View is loading a model or collection.\n    {{else}}\n      View is not loading a model or collection.\n    {{/loading}}\n\n## Catalog of Built-in Events\n\n### rendered *rendered ()*\n\nTriggered on a view when the `rendered` method is called.\n\n### child *child (instance)*\n\nTriggered on a view every time a child view is appened into the view with the `view` helper.\n\n### ready *ready (options)*\n\nTriggered when a view is append to the DOM with `appendTo` or when a view is appeneded to a `LayoutView` via `setView`. Setting focus and other behaviors that depend on the view being present in the DOM should be handled in this event.\n\nThis event propagates to all children, including children that will be bound after the view is created. `options` will contain a `target` view, which is the view that triggered the event.\n\n### activated *activated (options)*\n\nTriggered on a view immediately after it was passed to a `LayoutView`'s `setView` method. Like `ready` this event propagates to children and the `options` hash will contain a `target` view.\n\n### deactivated *deactivated (options)*\n\nTriggered on a view when it was previously passed to the `setView` method on a `LayoutView`, and then another view is passed to `setView`. Triggered when the current view's `el` is still attached to the parent. Like `ready` this event propagates to children and the `options` hash will contain a `target` view.\n\n### destroyed *destroyed ()*\n\nTriggered on a view when the `destroy` method is called. Useful for implementing custom view cleanup behaviors. `destroy` will be also be called if it was previously passed to the `setView` method on a `LayoutView`, and then another view is passed to `setView`.\n\n### change:view:start *change:view:start (newView [,oldView] ,options)*\n\nTrigged on a `Thorax.LayoutView` immediately after `setView` is called.\n\n### change:view:end *change:view:end (newView [,oldView] ,options)*\n\nTrigged on a `Thorax.LayoutView` after `setView` is called, the old view has been destroyed (if present) and the new view has been attached to the DOM and had its `ready` event triggered.\n\n### helper *helper (name [,args...] ,helperView)*\n\nTriggered on a view when a view helper (such as `collection`, `empty`, etc) create a new `HelperView` instance.\n\n### helper:name *helper:name ([,args...] ,helperView)*\n\nTriggered on a view when a given view helper creates a new `HelperView` instance.\n\n    {{#collection cats}}{{/collection}}\n\n    view.on('helper:collection', function(collection, collectionView) {\n\n    });\n\n### serialize *serialize (attributes)*\n\nTriggered on a view when `serialize` is called, before `validateInput` is called with the serialized attributes.\n\n### validate *validate (attributes, errors)*\n\nTriggered on a view when `serialize` is called, passed an an attributes hash and errors array after `validateInput` is called. Use in combination with the `error` event to display and clear errors from your views.\n\n    Thorax.View.on({\n      validate: function(attributes, errors) {\n        //clear previous errors if present\n      },\n      error: function(errors) {\n        errors.forEach(function(error) {\n          //lookup input by error.name\n          //display error from error.message\n        });\n      }\n    });\n\n### error *error (errors)*\n\nTriggered on a view when `serialize` is called, if validateInput returned an array with any errors.\n\n### populate *populate (attributes)*\n\nTriggered on a view when `populate` is called. Passed a hash containing the attributes that the view will be populated with.\n\n### load:start *load:start (message, background, target)*\n\nTriggered on a model or collection by `fetch` or `load` and on a view if it has bound the model or collection with `setModel` or `setCollection`. Always generate a handler for a `load:start` event with `Thorax.loadHandler`.\n\n### load:end *load:end (target)*\n\nTriggered on a model or collection by `fetch` or `load` and on a view if it has bound the model or collection with `setModel` or `setCollection`. Never observe this directly, always use `Thorax.loadHandler` on `load:start`.\n\n### rendered:collection *rendred:collection (collectionView, collection)*\n\nTriggered on a `CollectionView` or a the view calling the `collection` helper every time `render` is called on the `CollectionView`.\n\n### rendered:item *rendered:item (collectionView, collection, model, itemElement, index)*\n\nTriggered on a `CollectionView` or a the view calling the `collection` helper every time an item is rendered in the `CollectionView`.\n\n### rendered:empty *rendered:empty (collectionView, collection)*\n\nTriggered on a `CollectionView` or a the view calling the `collection` helper every time the `emptyView` or `emptyTemplate` is rendered in the `CollectionView`.\n\n## HTML Attributes\n\nThorax and its view helpers generate a number of custom HTML attributes that may be useful in debugging or generating CSS selectors to be used as arguments to `$` or to create CSS. The `*-cid` attributes are generally used only internally. See `$.model`, `$.collection` and `$.view` to get a reference to objects directly from the DOM. The `*-name` attributes will only be present if the given objects have a `name` property.</p>\n\n<table class=\"table table-bordered table-striped\">\n  <thead>\n    <tr>\n      <th>Attribute Name</th>\n      <th>Attached To</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr><td><code>data-view-cid</code></td><td>Every view instances' <code>el</code></td></tr>\n    <tr><td><code>data-view-name</code></td><td>Same as above, only present on named views</td></tr>\n    <tr><td><code>data-collection-cid</code></td><td>Element generated by the `collection helper`</td></tr>\n    <tr><td><code>data-collection-name</code></td><td>Same as above, only present when the bound collection is named</td></tr>\n    <tr><td><code>data-collection-empty</code></td><td>Set to \"true\" or \"false\" depending on whether the bound collection <code>isEmpty</code></td></tr>\n    <tr><td><code>data-collection-element</code></td><td>Set by the <code>collection-element</code>, determines where a collection in a <code>CollectionView</code> will be rendered.</td></tr>\n    <tr><td><code>data-model-cid</code></td><td>A view's <code>el</code> if a model was bound to the view or each item element inside of elements generated by the collection helper</td></tr>\n    <tr><td><code>data-model-name</code></td><td>Same as above, only present if the model is named</td></tr>\n    <tr><td><code>data-layout-cid</code></td><td>The element generated by the <code>layout</code> helper or <code>el</code> inside of a <code>LayoutView</code> or <code>ViewController</code> instance</td></tr>\n    <tr><td><code>data-view-helper</code></td><td>Elements generated by various helpers including <code>collection</code> and <code>empty</code> from the collection plugin</td></tr>\n    <tr><td><code>data-call-method</code></td><td>Elements generated by the <code>link</code> and <code>button</code> helpers</td></tr>\n    <tr><td><code>data-trigger-event</code></td><td>Elements generated by the <code>link</code> and <code>button</code> helpers</td></tr>\n  </tbody>\n</table>\n\nWhen creating CSS selectors it's recommended to use the generated attributes (especially `data-view-name`) rather than assigning custom IDs or class names for the sole purpose of styling.\n\n    [data-view-name=\"my-view-name\"] {\n      border: 1px solid #ccc;\n    }\n\n## Error Handling\n\n### onException *Thorax.onException(name, error)*\n\nBound DOM event handlers in Thorax are wrapped with a try / catch block, calling this function if an error is caught. This hook is provided primarily to allow for easier debugging in Android environments where it is difficult to determine the source of the error. The default error handler is simply:\n\n    Thorax.onException = function(name, error) {\n      throw error;\n    };\n\nOverride this function with your own logging / debugging handler. `name` will be the event name where the error was thrown.\n",
  "readmeFilename": "README.md",
  "_id": "thorax@2.0.0rc9",
  "description": "An opinionated, battle tested [Backbone](http://backbonejs.org/) + [Handlebars](http://handlebarsjs.com/) framework to build large scale web applications.",
  "repository": {
    "type": "git",
    "url": "git://github.com/walmartlabs/thorax.git"
  }
}